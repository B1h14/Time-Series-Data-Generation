"""
Utility functions for visualizing generated samples and model decompositions.
===========================================================================

This module provides functions to visualize samples generated by a diffusion model
and to visualize the trend and seasonality decomposition of time series data.

Functions:
- visualize_samples: Generates and visualizes samples from a diffusion model.
- visualize_decomposition: Visualizes the trend and seasonality components of a time series.
- visualize_diffusion_process: Visualizes the diffusion process of generated samples.

Usage:
------
from utils.visualisation import visualize_samples, visualize_decomposition
import torch.nn as nn
import torch
# Assume `model` is your trained model and `diffusion` is your diffusion process
visualize_samples(model, diffusion, n_samples=5, seq_len=512, save_path='samples.png')
data_sample = torch.randn(512, 1)  # Example data sample
visualize_decomposition(model, data_sample, save_path='decomposition.png')

# Visualize the diffusion process:
visualize_diffusion_process(model, diffusion, n_samples=5, seq_len=512, save_path='diffusion_process.png')

"""

import torch
import torch.nn as nn
import matplotlib.pyplot as plt

def visualize_samples(
        model : nn.Module,
        diffusion : nn.Module, 
        n_samples: int = 5,
        seq_len: int = 512,
        save_path: str = 'samples.png'
        )-> None:
    """Generate and visualize samples."""
    device = next(model.parameters()).device
    model.eval()

    with torch.no_grad():
        samples = diffusion.sample(n_samples, seq_len, 1)
        samples = samples.cpu().numpy()

    fig, axes = plt.subplots(n_samples, 1, figsize=(12, 2 * n_samples))
    if n_samples == 1:
        axes = [axes]

    for i, ax in enumerate(axes):
        ax.plot(samples[i, :, 0])
        ax.set_title(f'Generated Sample {i+1}')
        ax.set_xlabel('Time Step')
        ax.set_ylabel('Value')
        ax.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Samples saved to {save_path}")
def visualize_diffusion_process(
        model : nn.Module,
        diffusion : nn.Module, 
        n_samples: int = 5,
        seq_len: int = 512,
        save_path: str = 'samples.png'
        )-> None:
    """Generate and visualize samples showing the diffusion process."""
    device = next(model.parameters()).device
    model.eval()

    with torch.no_grad():
        samples, intermediates = diffusion.sample(n_samples, seq_len, 1, return_intermediates=True)
        samples = samples.cpu().numpy()
    displayed_intermediates = [intermediates[i].cpu().numpy() for i in range(0, len(intermediates), max(1, len(intermediates)//5))]
    fig, axes = plt.subplots(n_samples, 5, figsize=(12, 2 * n_samples))
    if n_samples == 1:
        axes = [axes]
    for j in range(5):
        for i in range(n_samples):
            axes[i][j].plot(displayed_intermediates[j][i, :, 0])
            if i == 0:
                axes[i][j].set_title(f'Sample {i+1} - Step {max(1, len(intermediates)//5) * (j+1)}')
            else:
                axes[i][j].set_title(f'Step {max(1, len(intermediates)//5) * (j+1)}')
            axes[i][j].set_xlabel('Time Step')
            axes[i][j].set_ylabel('Value')
            axes[i][j].grid(True, alpha=0.3)


    plt.tight_layout()
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Samples saved to {save_path}")

def visualize_decomposition(
        model: nn.Module,
        data_sample: torch.Tensor, 
        save_path: str = 'decomposition.png'
        ) -> None:
    """Visualize trend and seasonality decomposition."""
    device = next(model.parameters()).device
    model.eval()

    data_sample = data_sample.unsqueeze(0).to(device)
    t = torch.zeros((1,), device=device, dtype=torch.long)

    with torch.no_grad():
        output = model(data_sample, t)

    # Move to CPU for plotting
    original = data_sample.cpu().numpy()[0, :, 0]
    reconstructed = output['output'].cpu().numpy()[0, :, 0]
    trend = output['trend'].cpu().numpy()[0, :, 0]
    seasonality = output['seasonality'].cpu().numpy()[0, :, 0]
    residual = reconstructed - trend - seasonality

    fig, axes = plt.subplots(5, 1, figsize=(12, 10))

    axes[0].plot(original)
    axes[0].set_title('Original Signal')
    axes[0].grid(True, alpha=0.3)

    axes[1].plot(trend)
    axes[1].set_title('Trend Component')
    axes[1].grid(True, alpha=0.3)

    axes[2].plot(seasonality)
    axes[2].set_title('Seasonality Component')
    axes[2].grid(True, alpha=0.3)

    axes[3].plot(residual)
    axes[3].set_title('Residual Component')
    axes[3].grid(True, alpha=0.3)

    axes[4].plot(original, label='Original', alpha=0.7)
    axes[4].plot(reconstructed, label='Reconstructed', alpha=0.7)
    axes[4].set_title('Original vs Reconstructed')
    axes[4].legend()
    axes[4].grid(True, alpha=0.3)

    for ax in axes:
        ax.set_xlabel('Time Step')
        ax.set_ylabel('Value')

    plt.tight_layout()
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Decomposition saved to {save_path}")
